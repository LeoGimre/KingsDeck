package io.WizardsChessMaster.android;

import android.app.Activity;
import android.content.Intent;
import android.util.Log;

import androidx.annotation.Nullable;
import com.badlogic.gdx.Gdx;
import com.google.android.gms.auth.api.signin.*;
import com.google.android.gms.common.api.ApiException;
import com.google.android.gms.tasks.*;
import com.google.firebase.Timestamp;
import com.google.firebase.auth.*;
import com.google.firebase.firestore.*;

import java.security.SecureRandom;
import java.util.*;
import java.util.concurrent.Executor;
import java.util.stream.Collectors;

import io.WizardsChessMaster.model.BoardPosition;
import io.WizardsChessMaster.model.DeckModel;
import io.WizardsChessMaster.model.GameModel;
import io.WizardsChessMaster.model.GameStatus;
import io.WizardsChessMaster.model.MatchHistoryEntry;
import io.WizardsChessMaster.model.Team;
import io.WizardsChessMaster.model.UserModel;
import io.WizardsChessMaster.service.FirebaseService;
import io.WizardsChessMaster.model.spells.SpellConfig;
import io.WizardsChessMaster.model.spells.SpellFactory;

/**
 * Android implementation of the FirebasePresenter interface.
 * Handles interactions with Firebase Authentication and Firestore.
 */
public class AndroidFirebaseService implements FirebaseService {

    private static final String TAG = "AndroidFirebaseCtrl";
    private static final String USERS_COLLECTION = "users";
    private static final String DECKS_SUBCOLLECTION = "decks";
    private static final String MATCHMAKING_COLLECTION = "matchmakingQueue";
    private static final String GAMES_COLLECTION = "games";
    private static final String JOIN_CODES_COLLECTION = "joinCodes";
    private static final int K_FACTOR = 32;
    private static final int MAX_ELO_DIFF = 200;
    private static final int POSITION_HISTORY_LIMIT = 60;
    private static final int JOIN_CODE_LENGTH = 6;
    private static final String JOIN_CODE_CHARS = "ABCDEFGHIJKLMNPQRSTUVWXYZ123456789";
    private static final SecureRandom random = new SecureRandom();
    private static final String MOVED_SUFFIX = "_MOVED";
    private static final int MATCH_HISTORY_LIMIT = 20;


    private final Activity activity;
    private final FirebaseAuth mAuth;
    private final FirebaseFirestore db;
    private GoogleSignInClient mGoogleSignInClient;
    private final Executor mainThreadExecutor;

    public static final int RC_SIGN_IN = 9001;
    private AuthListener pendingAuthListener;
    // Listener management
    private ListenerRegistration activeRankedGameSearchListener = null;
    private String listeningForRankedUserId = null;
    private Map<String, ListenerRegistration> activeHostedGameListeners = new HashMap<>();


    public AndroidFirebaseService(Activity activity) {
        this.activity = activity;
        mAuth = FirebaseAuth.getInstance();
        db = FirebaseFirestore.getInstance();
        // Use Gdx.app.postRunnable to ensure callbacks run on the LibGDX thread
        mainThreadExecutor = command -> Gdx.app.postRunnable(command);

        // Configure Google Sign In
        String webClientId = null;
        try {
            // Ensure you have default_web_client_id in your strings.xml
            int resId = activity.getResources().getIdentifier("default_web_client_id", "string", activity.getPackageName());
            webClientId = (resId != 0) ? activity.getString(resId) : null;
        } catch (Exception e) {
            Log.e(TAG, "Error getting 'default_web_client_id'. Make sure it's in your strings.xml.", e);
        }
        if (webClientId != null) {
            GoogleSignInOptions gso = new GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
                    .requestIdToken(webClientId)
                    .requestEmail()
                    .build();
            mGoogleSignInClient = GoogleSignIn.getClient(activity, gso);
            Log.i(TAG, "Google Sign-In configured.");
        } else {
            Log.e(TAG, "Google Sign-In configuration failed: Web Client ID not found.");
            mGoogleSignInClient = null;
        }
    }

    // --- Authentication ---
    @Override public void signInWithGoogle(AuthListener listener) { if (mGoogleSignInClient == null) { Log.e(TAG, "Google Sign-In requested but not configured."); if(listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Google Sign-In not configured.")); return; } this.pendingAuthListener = listener; Intent signInIntent = mGoogleSignInClient.getSignInIntent(); try { Log.d(TAG, "Starting Google Sign-In activity..."); activity.startActivityForResult(signInIntent, RC_SIGN_IN); } catch (Exception e) { Log.e(TAG, "Failed to start Google Sign-In activity", e); if (pendingAuthListener != null) { AuthListener fl = pendingAuthListener; mainThreadExecutor.execute(() -> fl.onFailure("Failed to start sign-in: " + e.getMessage())); pendingAuthListener = null; } } }
    public void handleActivityResult(int requestCode, int resultCode, Intent data) { Log.d(TAG, "handleActivityResult: requestCode=" + requestCode); if (requestCode == RC_SIGN_IN) { Task<GoogleSignInAccount> task = GoogleSignIn.getSignedInAccountFromIntent(data); try { GoogleSignInAccount account = task.getResult(ApiException.class); Log.d(TAG, "Google Sign-In successful, attempting Firebase auth."); firebaseAuthWithGoogle(account.getIdToken()); } catch (ApiException e) { Log.e(TAG, "Google Sign-In failed (ApiException): " + e.getStatusCode() + " " + e.getMessage()); if (pendingAuthListener != null) { AuthListener fl = pendingAuthListener; mainThreadExecutor.execute(() -> fl.onFailure("Sign-in failed: " + e.getMessage() + " (Code: " + e.getStatusCode() + ")")); pendingAuthListener = null; } } catch (Exception e) { Log.e(TAG, "Google Sign-In failed (Exception): " + e.getMessage()); if (pendingAuthListener != null) { AuthListener fl = pendingAuthListener; mainThreadExecutor.execute(() -> fl.onFailure("Sign-in error: " + e.getMessage())); pendingAuthListener = null; } } } }
    private void firebaseAuthWithGoogle(String idToken) { if (idToken == null) { Log.e(TAG, "Firebase auth attempted with null ID token."); if (pendingAuthListener != null) { AuthListener fl = pendingAuthListener; mainThreadExecutor.execute(() -> fl.onFailure("Invalid token received from Google.")); pendingAuthListener = null; } return; } AuthCredential credential = GoogleAuthProvider.getCredential(idToken, null); mAuth.signInWithCredential(credential).addOnCompleteListener(activity, task -> { AuthListener finalListener = pendingAuthListener; pendingAuthListener = null; if (task.isSuccessful()) { FirebaseUser user = mAuth.getCurrentUser(); Log.i(TAG, "Firebase Authentication Successful. User: " + (user != null ? user.getUid() : "null")); if (user != null && finalListener != null) { createUserProfileIfNotExists(user.getUid(), user.getDisplayName(), new AuthListener() { @Override public void onSuccess() { Log.d(TAG, "User profile checked/created successfully."); mainThreadExecutor.execute(finalListener::onSuccess); } @Override public void onFailure(String errorMessage) { Log.e(TAG, "Profile check/creation failed after login: " + errorMessage); mainThreadExecutor.execute(finalListener::onSuccess); } }); } else if (finalListener != null) { Log.e(TAG, "Firebase auth task successful, but user is null or listener is null."); mainThreadExecutor.execute(() -> finalListener.onFailure("User data is null after sign-in task success.")); } } else { String errorMsg = task.getException() != null ? task.getException().getMessage() : "Unknown authentication error."; Log.e(TAG, "Firebase Authentication Failed: " + errorMsg, task.getException()); if (finalListener != null) { mainThreadExecutor.execute(() -> finalListener.onFailure("Firebase auth failed: " + errorMsg)); } } }); }
    @Override public void signOut(AuthListener listener) { Log.d(TAG, "Attempting sign out..."); mAuth.signOut(); if (mGoogleSignInClient != null) { mGoogleSignInClient.signOut().addOnCompleteListener(activity, task -> { if(task.isSuccessful()){ Log.i(TAG, "Google Sign Out successful."); } else { Log.w(TAG, "Google Sign Out failed.", task.getException()); } if(listener != null) mainThreadExecutor.execute(listener::onSuccess); }); } else { Log.d(TAG, "Firebase Sign Out complete (no Google client)."); if(listener != null) mainThreadExecutor.execute(listener::onSuccess); } }
    @Override public boolean isLoggedIn() { return mAuth.getCurrentUser() != null; }
    @Override public String getCurrentUserId() { FirebaseUser u = mAuth.getCurrentUser(); return (u != null) ? u.getUid() : null; }
    @Override public String getCurrentUserDisplayName() { FirebaseUser u = mAuth.getCurrentUser(); if (u != null) { return u.getDisplayName() != null ? u.getDisplayName() : "User"; } return "Guest"; }

    // --- User Profile ---
    @Override public void fetchUserProfile(UserProfileListener listener) { String userId = getCurrentUserId(); if (userId == null) { if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("User not logged in.")); return; } Log.d(TAG, "Fetching profile for user: " + userId); DocumentReference userDocRef = db.collection(USERS_COLLECTION).document(userId); userDocRef.get().addOnCompleteListener(task -> { if (task.isSuccessful()) { DocumentSnapshot document = task.getResult(); if (document != null && document.exists()) { UserModel userModel = null; try { userModel = document.toObject(UserModel.class); Log.d(TAG, "Profile data fetched for " + userId); } catch (Exception e) { Log.e(TAG, "Failed to parse profile for user " + userId, e); if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Failed to parse profile data.")); return; } if (userModel != null) { if (userModel.getUserId() == null) { userModel.setUserId(userId); } if (listener != null) { final UserModel finalUserModel = userModel; mainThreadExecutor.execute(() -> listener.onSuccess(finalUserModel)); } } else { Log.e(TAG, "Parsed profile model is null for user: " + userId); if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Failed to parse profile (model was null).")); } } else { FirebaseUser currentUser = mAuth.getCurrentUser(); if(currentUser != null) { Log.w(TAG, "User profile not found for " + userId + ". Attempting creation."); createUserProfileIfNotExists(currentUser.getUid(), currentUser.getDisplayName(), new AuthListener() { @Override public void onSuccess() { fetchUserProfile(listener); } @Override public void onFailure(String m) { if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Profile not found, and creation failed: " + m)); } }); } else { Log.e(TAG, "User became null during profile fetch when profile didn't exist."); if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("User became null during profile fetch.")); } } } else { String errorMsg = task.getException() != null ? task.getException().getMessage() : "Unknown Firestore error."; Log.e(TAG, "Firestore error fetching profile for " + userId + ": " + errorMsg, task.getException()); if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Firestore error: " + errorMsg)); } }); }
    @Override public void createUserProfileIfNotExists(String userId, String displayName, AuthListener listener) { if (userId == null) { if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("User ID is null.")); return; } DocumentReference userDocRef = db.collection(USERS_COLLECTION).document(userId); userDocRef.get().addOnCompleteListener(task -> { if (task.isSuccessful()) { DocumentSnapshot document = task.getResult(); if (document == null || !document.exists()) { String finalDisplayName = (displayName != null && !displayName.trim().isEmpty()) ? displayName.trim() : "User"; UserModel newUser = new UserModel(userId, finalDisplayName, 1000, 0, 0); Log.i(TAG, "Creating new user profile for " + userId + " with name: " + finalDisplayName); userDocRef.set(newUser) .addOnSuccessListener(aVoid -> { Log.d(TAG, "Profile created successfully for " + userId); if (listener != null) mainThreadExecutor.execute(listener::onSuccess); }) .addOnFailureListener(e -> { Log.e(TAG, "Failed to create profile for " + userId, e); if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Failed to create profile: " + e.getMessage())); }); } else { Log.d(TAG, "Profile already exists for " + userId); if (listener != null) mainThreadExecutor.execute(listener::onSuccess); } } else { String errorMsg = task.getException() != null ? task.getException().getMessage() : "Unknown Firestore error."; Log.e(TAG, "Error checking profile existence for " + userId + ": " + errorMsg, task.getException()); if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Error checking profile: " + errorMsg)); } }); }

    // --- Deck Management ---
    @Override public void saveDeck(DeckModel deck, DeckSaveListener listener) { String userId = getCurrentUserId(); if (userId == null) { if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Not logged in.")); return; } if (deck == null || deck.getName() == null || deck.getName().trim().isEmpty()) { if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Invalid deck name.")); return; } String docId = deck.getName().trim(); if (docId.isEmpty()) { if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Deck name cannot be empty after trimming.")); return; } deck.setName(docId); Log.d(TAG, "Saving deck '" + docId + "' for user " + userId); db.collection(USERS_COLLECTION).document(userId) .collection(DECKS_SUBCOLLECTION).document(docId) .set(deck) .addOnSuccessListener(aVoid -> { Log.i(TAG, "Deck '" + docId + "' saved successfully."); if (listener != null) mainThreadExecutor.execute(listener::onSuccess); }) .addOnFailureListener(e -> { Log.e(TAG, "Failed to save deck '" + docId + "'", e); if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Save failed: " + e.getMessage())); }); }
    @Override public void loadDecks(DeckLoadListener listener) { String userId = getCurrentUserId(); if (userId == null) { if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Not logged in.")); return; } Log.d(TAG, "Loading decks for user: " + userId); CollectionReference decksRef = db.collection(USERS_COLLECTION).document(userId).collection(DECKS_SUBCOLLECTION); decksRef.get().addOnCompleteListener(task -> { if (task.isSuccessful()) { List<DeckModel> decks = new ArrayList<>(); QuerySnapshot qs = task.getResult(); if (qs != null) { Log.d(TAG, "Found " + qs.size() + " deck documents."); for (QueryDocumentSnapshot doc : qs) { try { DeckModel deck = doc.toObject(DeckModel.class); if (deck.getName() == null || deck.getName().isEmpty()) { deck.setName(doc.getId()); } if (deck.getPieceConfiguration() == null) { deck.setPieceConfiguration(new HashMap<>()); } if (deck.getSpellConfiguration() == null) { deck.setSpellConfiguration(new HashMap<>()); } decks.add(deck); } catch (Exception e) { Log.e(TAG,"Failed to map deck document: " + doc.getId() + ". Data: " + doc.getData(), e); } } } Log.i(TAG, "Successfully loaded " + decks.size() + " decks for user " + userId); if (listener != null) mainThreadExecutor.execute(() -> listener.onSuccess(decks)); } else { String errorMsg = task.getException() != null ? task.getException().getMessage() : "Unknown Firestore error."; Log.e(TAG, "Error loading decks for " + userId + ": " + errorMsg, task.getException()); if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Error loading decks: " + errorMsg)); } }); }
    @Override public void deleteDeck(String deckName, DeckDeleteListener listener) { String userId = getCurrentUserId(); if (userId == null) { if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Not logged in.")); return; } if (deckName == null || deckName.trim().isEmpty()) { if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Invalid deck name.")); return; } String docId = deckName.trim(); Log.d(TAG, "Deleting deck '" + docId + "' for user " + userId); DocumentReference deckRef = db.collection(USERS_COLLECTION).document(userId) .collection(DECKS_SUBCOLLECTION).document(docId); deckRef.delete() .addOnSuccessListener(aVoid -> { Log.i(TAG, "Deck '" + docId + "' deleted successfully."); if (listener != null) mainThreadExecutor.execute(listener::onSuccess); }) .addOnFailureListener(e -> { Log.e(TAG, "Failed to delete deck '" + docId + "'", e); if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Delete failed: " + e.getMessage())); }); }

    // --- Matchmaking (Ranked) ---
    @Override public void enterRankedMatchmaking(String userId, String displayName, int elo, int pointLimit, String timeLimit, String deckName, AuthListener queueListener) { Log.i(TAG, "Entering RANKED matchmaking for user: " + userId + ", ELO: " + elo); enterMatchmaking(userId, displayName, elo, pointLimit, timeLimit, deckName, queueListener); }
    @Override public void cancelRankedMatchmaking(String userId, AuthListener listener) { Log.i(TAG, "Cancelling RANKED matchmaking for user: " + userId); cancelMatchmaking(userId, listener); }
    @Override public Object listenForMyRankedGame(String userId, GameFoundListener listener) { Log.d(TAG, "Starting listener for RANKED game for user: " + userId); return listenForMyGame(userId, listener); }
    @Override public void stopListeningForMyRankedGame(Object listenerRegistration) { Log.d(TAG, "Stopping listener for RANKED game."); stopListeningForMyGame(listenerRegistration); }

    // --- Matchmaking (Host & Join Custom Game) ---
    @Override public Object hostGame(String hostUserId, String hostDisplayName, int pointLimit, String timeLimit, String hostDeckName, HostedGameListener listener) { if (hostUserId == null || listener == null) { Log.e(TAG, "hostGame failed: Missing hostUserId or listener."); if(listener != null) mainThreadExecutor.execute(() -> listener.onError("Missing hostUserId or listener.")); return null; } Log.i(TAG, "Attempting to host game for user: " + hostUserId); DocumentReference gameRef = db.collection(GAMES_COLLECTION).document(); String joinCode = generateJoinCode(); Map<String, Object> gameData = new HashMap<>(); gameData.put("player1Id", hostUserId); gameData.put("playerIds", Arrays.asList(hostUserId)); gameData.put("player1DisplayName", hostDisplayName); gameData.put("player1DeckName", hostDeckName); gameData.put("pointLimit", pointLimit); gameData.put("timeLimit", timeLimit); gameData.put("status", GAME_STATUS_PENDING_CODE_JOIN); gameData.put("joinCode", joinCode); gameData.put("lastUpdateTime", FieldValue.serverTimestamp()); gameData.put("player2Id", null); gameData.put("player2DisplayName", null); gameData.put("player2DeckName", null); gameData.put("player1Color", null); gameData.put("player2Color", null); gameData.put("currentTurnPlayerId", null); gameData.put("boardState", new HashMap<>()); gameData.put("player1TimeRemainingMillis", 0L); gameData.put("player2TimeRemainingMillis", 0L); gameData.put("player1LastSeen", FieldValue.serverTimestamp()); gameData.put("player2LastSeen", null); gameData.put("drawOfferedByPlayerId", null); gameData.put("winnerId", null); gameData.put("loserId", null); gameData.put("winReason", null); gameData.put("eloChangePlayer1", 0); gameData.put("eloChangePlayer2", 0); gameData.put("fiftyMoveRuleCounter", 0); gameData.put("positionHistory", new ArrayList<String>()); gameData.put("enPassantTargetSquareString", null); gameData.put("player1Spells", new ArrayList<String>()); gameData.put("player2Spells", new ArrayList<String>()); DocumentReference codeRef = db.collection(JOIN_CODES_COLLECTION).document(joinCode); db.runTransaction((Transaction.Function<Void>) transaction -> { DocumentSnapshot existingCode = transaction.get(codeRef); if (existingCode.exists()) { Log.e(TAG, "Join code collision: " + joinCode); throw new FirebaseFirestoreException("Join code collision.", FirebaseFirestoreException.Code.ALREADY_EXISTS); } transaction.set(gameRef, gameData); Map<String, Object> codeData = new HashMap<>(); codeData.put("gameId", gameRef.getId()); codeData.put("hostId", hostUserId); codeData.put("createdAt", FieldValue.serverTimestamp()); transaction.set(codeRef, codeData); Log.d(TAG, "Transaction: Creating game " + gameRef.getId() + " and join code " + joinCode); return null; }).addOnSuccessListener(aVoid -> { Log.i(TAG, "Hosted game created successfully. GameID: " + gameRef.getId() + ", Code: " + joinCode); ListenerRegistration reg = gameRef.addSnapshotListener(mainThreadExecutor, (snapshot, error) -> { if (error != null) { Log.e(TAG, "Error listening to hosted game " + gameRef.getId(), error); stopHostedGameListener(gameRef.getId()); listener.onError("Listener error: " + error.getMessage()); return; } if (snapshot != null && snapshot.exists()) { GameModel gm = null; try { gm = snapshot.toObject(GameModel.class); if (gm != null) gm.setGameId(snapshot.getId()); } catch(Exception e) { Log.e(TAG, "Parse fail hosted game "+gameRef.getId(), e); } if (gm != null) { if (GAME_STATUS_PENDING_CODE_JOIN.equals(gm.getStatus())) { Log.d(TAG, "Listener update: Game " + gameRef.getId() + " still waiting for player."); } else if (GameStatus.ACTIVE.getFirestoreValue().equals(gm.getStatus()) && gm.getPlayer2Id() != null) { Log.i(TAG, "Player joined hosted game: " + gameRef.getId()); stopHostedGameListener(gameRef.getId()); listener.onPlayerJoined(gm); } else if (GameStatus.FINISHED.getFirestoreValue().equals(gm.getStatus()) || GameStatus.ERROR.getFirestoreValue().equals(gm.getStatus())) { Log.w(TAG, "Hosted game " + gameRef.getId() + " ended/cancelled before join. Status: " + gm.getStatus()); stopHostedGameListener(gameRef.getId()); listener.onHostingCancelled(); } } else { Log.e(TAG,"Hosted game snapshot parsing failed: "+gameRef.getId()); stopHostedGameListener(gameRef.getId()); listener.onError("Failed to parse game data update."); } } else { Log.w(TAG, "Hosted game document " + gameRef.getId() + " deleted."); stopHostedGameListener(gameRef.getId()); listener.onHostingCancelled(); } }); activeHostedGameListeners.put(gameRef.getId(), reg); listener.onWaitingForPlayer(gameRef.getId(), joinCode); }).addOnFailureListener(e -> { Log.e(TAG, "Failed to create hosted game.", e); listener.onError("Failed to create hosted game: " + e.getMessage()); }); return gameRef.getId(); }
    @Override public void cancelHostedGame(String gameId, @Nullable String hostUserId, AuthListener listener) { if (gameId == null) { if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Game ID missing.")); return; } Log.i(TAG, "Attempting to cancel hosted game: " + gameId); DocumentReference gameRef = db.collection(GAMES_COLLECTION).document(gameId); stopHostedGameListener(gameId); db.runTransaction((Transaction.Function<Void>) transaction -> { DocumentSnapshot gameSnap = transaction.get(gameRef); if (!gameSnap.exists()) { Log.w(TAG, "Attempted to cancel non-existent game: " + gameId); return null; } String status = gameSnap.getString("status"); String storedHostId = gameSnap.getString("player1Id"); String joinCode = gameSnap.getString("joinCode"); if (hostUserId != null && !hostUserId.equals(storedHostId)) { Log.w(TAG, "Permission denied cancelling game " + gameId + ". User " + hostUserId + " is not host " + storedHostId); throw new FirebaseFirestoreException("User is not the host.", FirebaseFirestoreException.Code.PERMISSION_DENIED); } if (!GAME_STATUS_PENDING_CODE_JOIN.equals(status)) { Log.w(TAG, "Cannot cancel game " + gameId + " because status is " + status); throw new FirebaseFirestoreException("Game is not waiting for join.", FirebaseFirestoreException.Code.FAILED_PRECONDITION); } transaction.delete(gameRef); Log.d(TAG, "TX: Deleting game document " + gameId); if (joinCode != null && !joinCode.isEmpty()) { DocumentReference codeRef = db.collection(JOIN_CODES_COLLECTION).document(joinCode); DocumentSnapshot codeSnap = transaction.get(codeRef); if (codeSnap.exists()) { transaction.delete(codeRef); Log.d(TAG, "TX: Deleting join code document " + joinCode); } else { Log.w(TAG, "TX: Join code document " + joinCode + " not found during game cancel."); } } return null; }).addOnSuccessListener(aVoid -> { Log.i(TAG, "Successfully cancelled hosted game: " + gameId); if (listener != null) mainThreadExecutor.execute(listener::onSuccess); }).addOnFailureListener(e -> { Log.e(TAG, "Failed to cancel hosted game: " + gameId, e); if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Cancel failed: " + e.getMessage())); }); }
    @Override public void stopHostingGameListener(Object listenerRegistration) { if (listenerRegistration instanceof String) { String gameId = (String) listenerRegistration; stopHostedGameListener(gameId); } else if (listenerRegistration != null) { Log.w(TAG, "stopHostingGameListener called with unexpected type: " + listenerRegistration.getClass().getName()); } }
    private void stopHostedGameListener(String gameId) { if (gameId != null && activeHostedGameListeners.containsKey(gameId)) { ListenerRegistration reg = activeHostedGameListeners.remove(gameId); if (reg != null) { reg.remove(); Log.i(TAG, "Stopped and removed hosted game listener for game: " + gameId); } } }
    private static class PointLimitMismatchException extends FirebaseFirestoreException { private final int requiredLimit; public PointLimitMismatchException(int requiredLimit) { super("Player deck point limit exceeds host limit.", Code.FAILED_PRECONDITION); this.requiredLimit = requiredLimit; } public int getRequiredLimit() { return requiredLimit; } }
    @Override public void joinGameByCode(String joinerUserId, String joinerDisplayName, DeckModel joinerDeckModel, String joinCode, JoinGameListener listener) { if (joinerUserId == null || joinerDeckModel == null || joinCode == null || listener == null) { if (listener != null) mainThreadExecutor.execute(() -> listener.onJoinFailure("Missing parameters for join.")); return; } final String codeUpper = joinCode.toUpperCase().trim(); if (codeUpper.length() != JOIN_CODE_LENGTH) { mainThreadExecutor.execute(() -> listener.onJoinFailure("Invalid code format.")); return; } Log.i(TAG, "Player " + joinerUserId + " attempting to join game with code: " + codeUpper); DocumentReference codeRef = db.collection(JOIN_CODES_COLLECTION).document(codeUpper); codeRef.get().addOnCompleteListener(task -> { if (!task.isSuccessful()) { Log.e(TAG, "Error fetching join code " + codeUpper, task.getException()); mainThreadExecutor.execute(() -> listener.onJoinFailure("Error finding game: " + task.getException().getMessage())); return; } DocumentSnapshot codeDoc = task.getResult(); if (codeDoc == null || !codeDoc.exists()) { Log.w(TAG, "Join code not found: " + codeUpper); mainThreadExecutor.execute(() -> listener.onJoinFailure("Invalid join code.")); return; } String gameId = codeDoc.getString("gameId"); String hostId = codeDoc.getString("hostId"); if (gameId == null || hostId == null) { Log.e(TAG, "Join code document " + codeUpper + " missing gameId or hostId."); mainThreadExecutor.execute(() -> listener.onJoinFailure("Game data corrupted (code info).")); return; } if (hostId.equals(joinerUserId)) { mainThreadExecutor.execute(() -> listener.onJoinFailure("Cannot join your own game.")); return; } DocumentReference gameRef = db.collection(GAMES_COLLECTION).document(gameId); db.runTransaction((Transaction.Function<GameModel>) transaction -> { DocumentSnapshot gameSnap = transaction.get(gameRef); if (!gameSnap.exists()) { Log.w(TAG, "Game " + gameId + " associated with code " + codeUpper + " not found."); throw new FirebaseFirestoreException("Game not found.", FirebaseFirestoreException.Code.NOT_FOUND); } GameModel game = gameSnap.toObject(GameModel.class); if (game == null) { Log.e(TAG, "Failed to parse game " + gameId); throw new FirebaseFirestoreException("Game data corrupted.", FirebaseFirestoreException.Code.DATA_LOSS); } game.setGameId(gameId); if (!GAME_STATUS_PENDING_CODE_JOIN.equals(game.getStatus())) { Log.w(TAG, "Attempted to join game " + gameId + " but status is " + game.getStatus()); throw new FirebaseFirestoreException("Game is no longer waiting for players.", FirebaseFirestoreException.Code.FAILED_PRECONDITION); } int hostPointLimit = game.getPointLimit(); int joinerPoints = joinerDeckModel.getCurrentPoints(); if (joinerPoints > hostPointLimit) { Log.w(TAG, "Join failed: Player " + joinerUserId + " deck (" + joinerPoints + "pts) exceeds host limit (" + hostPointLimit + "pts) for game " + gameId); throw new PointLimitMismatchException(hostPointLimit); } String p1Clr = new Random().nextBoolean() ? "white" : "black"; String p2Clr = p1Clr.equals("white") ? "black" : "white"; String firstTurnId = p1Clr.equals("white") ? game.getPlayer1Id() : joinerUserId; long initialTime = calculateInitialTimeMillis(game.getTimeLimit()); Map<String, Object> updates = new HashMap<>(); updates.put("player2Id", joinerUserId); updates.put("playerIds", Arrays.asList(game.getPlayer1Id(), joinerUserId)); updates.put("player2DisplayName", joinerDisplayName); updates.put("player2DeckName", joinerDeckModel.getName()); updates.put("player1Color", p1Clr); updates.put("player2Color", p2Clr); updates.put("status", GameStatus.ACTIVE.getFirestoreValue()); updates.put("currentTurnPlayerId", firstTurnId); updates.put("player1TimeRemainingMillis", initialTime); updates.put("player2TimeRemainingMillis", initialTime); updates.put("lastUpdateTime", FieldValue.serverTimestamp()); updates.put("player2LastSeen", FieldValue.serverTimestamp()); updates.put("joinCode", FieldValue.delete()); Log.d(TAG, "TX: Joining game " + gameId + " as player 2. Updates: " + updates.keySet()); transaction.update(gameRef, updates); transaction.delete(codeRef); Log.d(TAG, "TX: Deleting join code " + codeUpper); game.setPlayer2Id(joinerUserId); game.setPlayerIds(Arrays.asList(game.getPlayer1Id(), joinerUserId)); game.setPlayer2DisplayName(joinerDisplayName); game.setPlayer2DeckName(joinerDeckModel.getName()); game.setPlayer1Color(p1Clr); game.setPlayer2Color(p2Clr); game.setStatusEnum(GameStatus.ACTIVE); game.setCurrentTurnPlayerId(firstTurnId); game.setPlayer1TimeRemainingMillis(initialTime); game.setPlayer2TimeRemainingMillis(initialTime); game.setPlayer2LastSeen(new Date()); return game; }).addOnSuccessListener(updatedGameModel -> { Log.i(TAG, "Successfully joined game " + updatedGameModel.getGameId() + " via code " + codeUpper); mainThreadExecutor.execute(() -> listener.onJoinSuccess(updatedGameModel)); }).addOnFailureListener(e -> { if (e instanceof PointLimitMismatchException) { Log.w(TAG, "Join game failed due to point limit mismatch.", e); int requiredLimit = ((PointLimitMismatchException) e).getRequiredLimit(); mainThreadExecutor.execute(() -> listener.onPointLimitMismatch(requiredLimit)); } else { Log.e(TAG, "Failed to join game " + gameId + " via code " + codeUpper, e); mainThreadExecutor.execute(() -> listener.onJoinFailure("Join failed: " + e.getMessage())); } }); }); }
    private String generateJoinCode() { StringBuilder code = new StringBuilder(JOIN_CODE_LENGTH); for (int i = 0; i < JOIN_CODE_LENGTH; i++) { code.append(JOIN_CODE_CHARS.charAt(random.nextInt(JOIN_CODE_CHARS.length()))); } return code.toString(); }


    // --- General Game Status --- (Unchanged)
    @Override public void checkForActiveGame(String userId, ActiveGameCheckListener listener) { if (userId == null) { if (listener != null) mainThreadExecutor.execute(() -> listener.onError("User ID is null.")); return; } Log.d(TAG, "Checking for active game for user: " + userId); db.collection(GAMES_COLLECTION) .whereArrayContains("playerIds", userId) .whereIn("status", Arrays.asList( GameStatus.ACTIVE.getFirestoreValue(), GameStatus.PENDING_JOIN.getFirestoreValue(), GAME_STATUS_PENDING_CODE_JOIN )) .orderBy("lastUpdateTime", Query.Direction.DESCENDING) .limit(1) .get() .addOnCompleteListener(task -> { if (task.isSuccessful()) { QuerySnapshot qs = task.getResult(); if (qs != null && !qs.isEmpty()) { DocumentSnapshot gameDoc = qs.getDocuments().get(0); try { GameModel gameModel = gameDoc.toObject(GameModel.class); if (gameModel != null) { gameModel.setGameId(gameDoc.getId()); if (gameModel.getPlayer1Spells() == null) gameModel.setPlayer1Spells(new ArrayList<>()); if (gameModel.getPlayer2Spells() == null) gameModel.setPlayer2Spells(new ArrayList<>()); Log.i(TAG, "Found active/pending game for user " + userId + ": " + gameDoc.getId() + " (Status: " + gameModel.getStatus() + ")"); if (GAME_STATUS_PENDING_CODE_JOIN.equals(gameModel.getStatus()) && gameModel.getPlayer2Id() == null) { Log.d(TAG, "Game "+ gameDoc.getId() +" is hosted and waiting. Treating as 'No Active Game' for this check."); if (listener != null) { mainThreadExecutor.execute(listener::onNoActiveGameFound); } } else { if (listener != null) { mainThreadExecutor.execute(() -> listener.onActiveGameFound(gameModel)); } } } else { Log.e(TAG, "Failed to parse active game data for user " + userId + ", doc: " + gameDoc.getId()); if (listener != null) { mainThreadExecutor.execute(listener::onNoActiveGameFound); } } } catch (Exception e) { Log.e(TAG, "Error parsing game data during active game check for user " + userId, e); if (listener != null) { mainThreadExecutor.execute(() -> listener.onError("Error parsing game data: " + e.getMessage())); } } } else { Log.d(TAG, "No active or pending game found for user: " + userId); if (listener != null) { mainThreadExecutor.execute(listener::onNoActiveGameFound); } } } else { String errorMsg = task.getException() != null ? task.getException().getMessage() : "Unknown Firestore error."; Log.e(TAG, "Error checking for active game for user " + userId + ": " + errorMsg, task.getException()); if (listener != null) { mainThreadExecutor.execute(() -> listener.onError("Error checking games: " + errorMsg)); } } }); }

    // --- Gameplay ---
    @Override public Object listenToGameUpdates(String gameId, GameEventListener listener) { if (gameId == null || listener == null) return null; Log.d(TAG, "Starting listener for game updates: " + gameId); DocumentReference gameRef = db.collection(GAMES_COLLECTION).document(gameId); return gameRef.addSnapshotListener(mainThreadExecutor, (snapshot, e) -> { if (e != null) { Log.e(TAG, "Listen game error for game: " + gameId, e); String errorMsg = "Listener error: " + e.getMessage(); if (e instanceof FirebaseFirestoreException) { FirebaseFirestoreException.Code code = ((FirebaseFirestoreException) e).getCode(); if (code == FirebaseFirestoreException.Code.PERMISSION_DENIED) errorMsg = "Permission denied listening to game."; else if (code == FirebaseFirestoreException.Code.UNAUTHENTICATED) errorMsg = "Authentication error listening to game."; else errorMsg = "Firestore error: " + e.getMessage(); } listener.onError(errorMsg); return; } if (snapshot != null && snapshot.exists()) { try { GameModel gm = snapshot.toObject(GameModel.class); if (gm != null) { gm.setGameId(snapshot.getId()); if (gm.getPlayer1Spells() == null) gm.setPlayer1Spells(new ArrayList<>()); if (gm.getPlayer2Spells() == null) gm.setPlayer2Spells(new ArrayList<>()); listener.onGameStateUpdate(gm); if (gm.getStatusEnum() == GameStatus.FINISHED) { listener.onGameEnded(gm); } } else { Log.e(TAG, "Failed to parse game data from snapshot for game: " + gameId); listener.onError("Failed to parse game data for game: " + gameId); } } catch (Exception pe) { Log.e(TAG, "Parse Error processing game update: " + gameId, pe); listener.onError("Parse Error: " + pe.getMessage()); } } else { Log.w(TAG, "Game document not found (or deleted): " + gameId); listener.onError("Game not found (or deleted): " + gameId); } }); }
    @Override public void stopListeningToGame(Object listenerRegistration) { if (listenerRegistration instanceof ListenerRegistration) { ((ListenerRegistration) listenerRegistration).remove(); Log.d(TAG, "Stopped game listener."); } }
    @Override public void offerDraw(String gameId, String offeringPlayerId, AuthListener listener) { if (gameId == null || offeringPlayerId == null) { if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("ID missing.")); return; } Log.i(TAG, "Player " + offeringPlayerId + " offering draw for game: " + gameId); DocumentReference gameRef = db.collection(GAMES_COLLECTION).document(gameId); db.runTransaction((Transaction.Function<Void>) tx -> { DocumentSnapshot snap = tx.get(gameRef); if (!snap.exists()) throw new FirebaseFirestoreException("Game not found.", FirebaseFirestoreException.Code.NOT_FOUND); GameModel g = snap.toObject(GameModel.class); if (g==null) throw new FirebaseFirestoreException("Parse fail.", FirebaseFirestoreException.Code.DATA_LOSS); if (g.getStatusEnum() != GameStatus.ACTIVE) throw new FirebaseFirestoreException("Game not active.", FirebaseFirestoreException.Code.FAILED_PRECONDITION); if (g.hasPendingDrawOffer()) throw new FirebaseFirestoreException("Draw offer already pending.", FirebaseFirestoreException.Code.FAILED_PRECONDITION); if (!offeringPlayerId.equals(g.getCurrentTurnPlayerId())) throw new FirebaseFirestoreException("Cannot offer draw: Not your turn.", FirebaseFirestoreException.Code.FAILED_PRECONDITION); Map<String, Object> updates = new HashMap<>(); updates.put("drawOfferedByPlayerId", offeringPlayerId); updates.put("lastUpdateTime", FieldValue.serverTimestamp()); tx.update(gameRef, updates); Log.d(TAG, "TX: Offering draw by " + offeringPlayerId); return null; }).addOnSuccessListener(aVoid -> { Log.i(TAG, "Draw offer successful for game: " + gameId); if (listener != null) mainThreadExecutor.execute(listener::onSuccess); }).addOnFailureListener(e -> { Log.e(TAG, "Draw offer failed for game: " + gameId, e); if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure(e.getMessage())); }); }
    @Override public void acceptDraw(String gameId, String acceptingPlayerId, GameEndListener listener) { if (gameId == null || acceptingPlayerId == null) { if (listener != null) mainThreadExecutor.execute(() -> listener.onGameEndFailure("ID missing.")); return; } DocumentReference gameRef = db.collection(GAMES_COLLECTION).document(gameId); Log.i(TAG, "Player " + acceptingPlayerId + " attempting to accept draw for game: " + gameId); db.runTransaction((Transaction.Function<Integer>) tx -> { DocumentSnapshot snap = tx.get(gameRef); if (!snap.exists()) throw new FirebaseFirestoreException("Game not found.", FirebaseFirestoreException.Code.NOT_FOUND); GameModel g = snap.toObject(GameModel.class); if (g==null) throw new FirebaseFirestoreException("Parse fail.", FirebaseFirestoreException.Code.DATA_LOSS); if (g.getStatusEnum() != GameStatus.ACTIVE) throw new FirebaseFirestoreException("Game not active.", FirebaseFirestoreException.Code.FAILED_PRECONDITION); if (!g.hasPendingDrawOffer()) throw new FirebaseFirestoreException("No pending draw offer.", FirebaseFirestoreException.Code.FAILED_PRECONDITION); if (acceptingPlayerId.equals(g.getDrawOfferedByPlayerId())) throw new FirebaseFirestoreException("Cannot accept own draw offer.", FirebaseFirestoreException.Code.FAILED_PRECONDITION); String p1Id = g.getPlayer1Id(); String p2Id = g.getPlayer2Id(); if (p1Id == null || p2Id == null) throw new FirebaseFirestoreException("Player IDs missing in game data.", FirebaseFirestoreException.Code.DATA_LOSS); Map<String, Object> gameUpdates = new HashMap<>(); gameUpdates.put("status", GameStatus.FINISHED.getFirestoreValue()); gameUpdates.put("winnerId", null); gameUpdates.put("loserId", null); gameUpdates.put("winReason", WIN_REASON_DRAW_AGREEMENT); gameUpdates.put("drawOfferedByPlayerId", null); gameUpdates.put("eloChangePlayer1", 0); gameUpdates.put("eloChangePlayer2", 0); gameUpdates.put("lastUpdateTime", FieldValue.serverTimestamp()); Log.d(TAG, "TX_acceptDraw: gameUpdates=" + gameUpdates); tx.update(gameRef, gameUpdates); Map<String, Object> p1Up = new HashMap<>(); p1Up.put("gamesPlayed", FieldValue.increment(1)); tx.update(db.collection(USERS_COLLECTION).document(p1Id), p1Up); Map<String, Object> p2Up = new HashMap<>(); p2Up.put("gamesPlayed", FieldValue.increment(1)); tx.update(db.collection(USERS_COLLECTION).document(p2Id), p2Up); Log.d(TAG, "TX: Incrementing gamesPlayed for " + p1Id + " and " + p2Id); return 0; }).addOnSuccessListener(eloChange -> { Log.i(TAG, "Draw accept transaction successful for game: " + gameId); if (listener != null) mainThreadExecutor.execute(() -> listener.onGameEndSuccess(eloChange)); }).addOnFailureListener(e -> { Log.e(TAG, "Draw accept transaction failed for game: " + gameId, e); if (listener != null) mainThreadExecutor.execute(() -> listener.onGameEndFailure(e.getMessage())); }); }
    @Override public void declineDraw(String gameId, String decliningPlayerId, AuthListener listener) { if (gameId == null || decliningPlayerId == null) { if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("ID missing.")); return; } Log.i(TAG, "Player " + decliningPlayerId + " declining draw for game: " + gameId); DocumentReference gameRef = db.collection(GAMES_COLLECTION).document(gameId); db.runTransaction((Transaction.Function<Void>) tx -> { DocumentSnapshot snap = tx.get(gameRef); if (!snap.exists()) throw new FirebaseFirestoreException("Game not found.", FirebaseFirestoreException.Code.NOT_FOUND); GameModel g = snap.toObject(GameModel.class); if (g==null) throw new FirebaseFirestoreException("Parse fail.", FirebaseFirestoreException.Code.DATA_LOSS); if (g.getStatusEnum() != GameStatus.ACTIVE) throw new FirebaseFirestoreException("Game not active.", FirebaseFirestoreException.Code.FAILED_PRECONDITION); if (!g.hasPendingDrawOffer()) throw new FirebaseFirestoreException("No pending draw offer.", FirebaseFirestoreException.Code.FAILED_PRECONDITION); if (decliningPlayerId.equals(g.getDrawOfferedByPlayerId())) throw new FirebaseFirestoreException("Cannot decline own draw offer.", FirebaseFirestoreException.Code.FAILED_PRECONDITION); Map<String, Object> updates = new HashMap<>(); updates.put("drawOfferedByPlayerId", null); updates.put("lastUpdateTime", FieldValue.serverTimestamp()); tx.update(gameRef, updates); Log.d(TAG, "TX: Declining draw by " + decliningPlayerId); return null; }).addOnSuccessListener(aVoid -> { Log.i(TAG, "Draw decline successful for game: " + gameId); if (listener != null) mainThreadExecutor.execute(listener::onSuccess); }).addOnFailureListener(e -> { Log.e(TAG, "Draw decline failed for game: " + gameId, e); if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure(e.getMessage())); }); }
    @Override public void resignGame(String gameId, String resigningPlayerId, GameEndListener listener) { if (gameId == null || resigningPlayerId == null) { if (listener != null) mainThreadExecutor.execute(() -> listener.onGameEndFailure("ID missing.")); return; } DocumentReference gameRef = db.collection(GAMES_COLLECTION).document(gameId); Log.i(TAG, "Player " + resigningPlayerId + " resigning game: " + gameId); db.runTransaction((Transaction.Function<Integer>) tx -> { DocumentSnapshot snap = tx.get(gameRef); if (!snap.exists()) throw new FirebaseFirestoreException("Game not found.", FirebaseFirestoreException.Code.NOT_FOUND); GameModel g = snap.toObject(GameModel.class); if (g==null) throw new FirebaseFirestoreException("Parse fail.", FirebaseFirestoreException.Code.DATA_LOSS); if (g.getStatusEnum() == GameStatus.FINISHED) { Log.w(TAG,"Attempted resignation for already finished game: "+gameId); throw new FirebaseFirestoreException("Game already finished.", FirebaseFirestoreException.Code.ABORTED); } String winnerId, loserId = resigningPlayerId; if (resigningPlayerId.equals(g.getPlayer1Id())) { winnerId = g.getPlayer2Id(); } else if (resigningPlayerId.equals(g.getPlayer2Id())) { winnerId = g.getPlayer1Id(); } else { throw new FirebaseFirestoreException("Resigning player not found in game.", FirebaseFirestoreException.Code.FAILED_PRECONDITION); } if (winnerId == null) throw new FirebaseFirestoreException("Opponent ID missing.", FirebaseFirestoreException.Code.FAILED_PRECONDITION); DocumentReference winRef = db.collection(USERS_COLLECTION).document(winnerId); DocumentReference loseRef = db.collection(USERS_COLLECTION).document(loserId); DocumentSnapshot winSnap = tx.get(winRef); DocumentSnapshot loseSnap = tx.get(loseRef); if (!winSnap.exists() || !loseSnap.exists()) throw new FirebaseFirestoreException("Player profile missing for ELO calculation.", FirebaseFirestoreException.Code.NOT_FOUND); UserModel w = winSnap.toObject(UserModel.class); UserModel l = loseSnap.toObject(UserModel.class); if (w == null || l == null) throw new FirebaseFirestoreException("Player profile parse fail.", FirebaseFirestoreException.Code.DATA_LOSS); w.setUserId(winnerId); l.setUserId(loserId); double wEx = 1.0 / (1.0 + Math.pow(10.0, (l.getEloRating() - w.getEloRating()) / 400.0)); double lEx = 1.0 - wEx; int eloW_ch = (int) Math.round(K_FACTOR * (1.0 - wEx)); int eloL_ch = (int) Math.round(K_FACTOR * (0.0 - lEx)); int newW_elo = Math.max(100, w.getEloRating() + eloW_ch); int newL_elo = Math.max(100, l.getEloRating() + eloL_ch); eloW_ch = newW_elo - w.getEloRating(); eloL_ch = newL_elo - l.getEloRating(); Map<String, Object> gameUpdates = new HashMap<>(); gameUpdates.put("status", GameStatus.FINISHED.getFirestoreValue()); gameUpdates.put("winnerId", winnerId); gameUpdates.put("loserId", loserId); gameUpdates.put("winReason", WIN_REASON_RESIGNATION); gameUpdates.put("drawOfferedByPlayerId", null); if (winnerId.equals(g.getPlayer1Id())) { gameUpdates.put("eloChangePlayer1", eloW_ch); gameUpdates.put("eloChangePlayer2", eloL_ch); } else { gameUpdates.put("eloChangePlayer1", eloL_ch); gameUpdates.put("eloChangePlayer2", eloW_ch); } gameUpdates.put("lastUpdateTime", FieldValue.serverTimestamp()); Log.d(TAG, "TX_resignGame: gameUpdates=" + gameUpdates); tx.update(gameRef, gameUpdates); Map<String, Object> winnerUpdates = new HashMap<>(); winnerUpdates.put("eloRating", newW_elo); winnerUpdates.put("gamesPlayed", FieldValue.increment(1)); winnerUpdates.put("gamesWon", FieldValue.increment(1)); tx.update(winRef, winnerUpdates); Map<String, Object> loserUpdates = new HashMap<>(); loserUpdates.put("eloRating", newL_elo); loserUpdates.put("gamesPlayed", FieldValue.increment(1)); tx.update(loseRef, loserUpdates); Log.d(TAG, "TX: Updating ELO. Winner ("+winnerId+"): "+w.getEloRating()+" -> "+newW_elo+" ("+eloW_ch+"). Loser ("+loserId+"): "+l.getEloRating()+" -> "+newL_elo+" ("+eloL_ch+")"); return eloL_ch; }).addOnSuccessListener(resigningPlayerEloChange -> { Log.i(TAG, "Resignation transaction successful for game: " + gameId + ", Resigner ELO change: " + resigningPlayerEloChange); if (listener != null) mainThreadExecutor.execute(() -> listener.onGameEndSuccess(resigningPlayerEloChange)); }).addOnFailureListener(e -> { Log.e(TAG, "Resignation transaction failed for game: " + gameId, e); if (listener != null) { String msg = e.getMessage(); if (e instanceof FirebaseFirestoreException && ((FirebaseFirestoreException)e).getCode()==FirebaseFirestoreException.Code.ABORTED) { msg="Game already finished."; } final String finalMsg = msg; mainThreadExecutor.execute(() -> listener.onGameEndFailure("Resignation failed: " + finalMsg)); } }); }
    @Override public void updateLastSeen(String gameId, String playerId, AuthListener listener) { if (gameId == null || playerId == null) { if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Missing IDs for updateLastSeen")); return; } DocumentReference gameRef = db.collection(GAMES_COLLECTION).document(gameId); gameRef.get().addOnSuccessListener(doc -> { if (!doc.exists()) { if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Game not found for lastSeen update.")); return; } String p1Id = doc.getString("player1Id"); String p2Id = doc.getString("player2Id"); String fieldToUpdate = null; if (playerId.equals(p1Id)) { fieldToUpdate = "player1LastSeen"; } else if (playerId.equals(p2Id)) { fieldToUpdate = "player2LastSeen"; } if (fieldToUpdate != null) { gameRef.update(fieldToUpdate, FieldValue.serverTimestamp()) .addOnSuccessListener(aVoid -> { if (listener != null) mainThreadExecutor.execute(listener::onSuccess); }) .addOnFailureListener(e -> { if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure(e.getMessage())); }); } else { Log.w(TAG, "Player ID " + playerId + " not found in game " + gameId + " for lastSeen update."); if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Player not found in game.")); } }).addOnFailureListener(e -> { if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure(e.getMessage())); }); }
    @Override public void initializePlayerBoardStateTransactionally(String gameId, String playerId, String playerColor, DeckModel playerDeckModel, AuthListener listener) { if (gameId == null || playerId == null || playerColor == null || playerDeckModel == null) { if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Missing parameters for board initialization.")); return; } Log.i(TAG, "Initializing board state TX for player " + playerId + " (" + playerColor + ") in game " + gameId); DocumentReference gameRef = db.collection(GAMES_COLLECTION).document(gameId); db.runTransaction((Transaction.Function<Void>) tx -> { DocumentSnapshot snap = tx.get(gameRef); if (!snap.exists()) throw new FirebaseFirestoreException("Game not found.", FirebaseFirestoreException.Code.NOT_FOUND); GameModel game = snap.toObject(GameModel.class); if (game == null) throw new FirebaseFirestoreException("Failed to parse game.", FirebaseFirestoreException.Code.DATA_LOSS); if (game.getStatusEnum() != GameStatus.ACTIVE) { Log.w(TAG,"initializePlayerBoardState skipped, game status is: "+ game.getStatusEnum()); return null; } Map<String, Object> updates = new HashMap<>(); String playerFieldPrefix = playerId.equals(game.getPlayer1Id()) ? "player1" : "player2"; String playerSpellsField = playerFieldPrefix + "Spells"; Map<String, Object> existingBoard = game.getBoardState(); boolean playerPiecesExist = false; if (existingBoard != null) { String expectedPrefix = playerColor.toUpperCase() + "_"; for(Object val : existingBoard.values()) { if (val instanceof String && ((String)val).startsWith(expectedPrefix)) { playerPiecesExist = true; break; } } } if (!playerPiecesExist) { Map<String, Object> currentBoard = (existingBoard != null) ? new HashMap<>(existingBoard) : new HashMap<>(); Map<String, String> piecesToAdd = generatePlayerInitialPieces(playerColor, playerDeckModel); int piecesAddedCount = 0; for (Map.Entry<String, String> entry : piecesToAdd.entrySet()) { if (!currentBoard.containsKey(entry.getKey()) || currentBoard.get(entry.getKey()) == null) { currentBoard.put(entry.getKey(), entry.getValue()); piecesAddedCount++; } } if (piecesAddedCount > 0) { updates.put("boardState", currentBoard); Log.d(TAG, "TX: Added " + piecesAddedCount + " pieces for " + playerColor); } else { Log.d(TAG, "TX: No pieces needed to be added for " + playerColor + " (squares might be occupied or already set)."); } } else { Log.d(TAG, "TX: Pieces for " + playerColor + " already exist on board."); } Object currentSpellsObj = snap.get(playerSpellsField); List<String> currentSpellsInGame = null; if (currentSpellsObj instanceof List) { try { @SuppressWarnings("unchecked") List<String> castedList = (List<String>) currentSpellsObj; currentSpellsInGame = castedList; } catch (ClassCastException cce) { Log.w(TAG, "Could not cast spell list to List<String> for field: " + playerSpellsField, cce); } } if (currentSpellsInGame == null || currentSpellsInGame.isEmpty()) { List<String> spellNamesFromDeck = playerDeckModel.getSpellConfiguration().values().stream() .filter(Objects::nonNull) .collect(Collectors.toList()); if (!spellNamesFromDeck.isEmpty()) { updates.put(playerSpellsField, spellNamesFromDeck); Log.d(TAG, "TX: Initializing spells for " + playerId + " (" + playerSpellsField + ") with: " + spellNamesFromDeck); } else { updates.put(playerSpellsField, new ArrayList<String>()); Log.d(TAG, "TX: Initializing empty spell list for " + playerId + " (" + playerSpellsField + ") as deck has no spells."); } } else { Log.d(TAG, "TX: Spells for " + playerId + " (" + playerSpellsField + ") already initialized."); } if (!updates.isEmpty()) { updates.put("lastUpdateTime", FieldValue.serverTimestamp()); tx.update(gameRef, updates); Log.d(TAG,"TX_initializePlayerState: Updating fields: " + updates.keySet()); } else { Log.d(TAG,"TX_initializePlayerState: No updates needed for player " + playerId); } return null; }).addOnSuccessListener(aVoid -> { Log.i(TAG, "Board/Spell initialization TX successful for player " + playerId); if (listener != null) mainThreadExecutor.execute(listener::onSuccess); }).addOnFailureListener(e -> { Log.e(TAG, "Board/Spell initialization TX failed for player " + playerId, e); if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure(e.getMessage())); }); }
    @Override public void performMove(String gameId, String originalSquare, String targetSquare, String pieceValue, String nextTurnPlayerId, boolean isCapture, boolean isPawnMove, boolean isRangedAttack, long player1TimeRemaining, long player2TimeRemaining, AuthListener listener) { if (gameId == null || originalSquare == null || targetSquare == null || pieceValue == null || nextTurnPlayerId == null) { if(listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Invalid move arguments")); Log.e(TAG, "performMove called with null arguments"); return; } DocumentReference gameRef = db.collection(GAMES_COLLECTION).document(gameId); Log.i(TAG, "Performing move: " + pieceValue + " " + originalSquare + "->" + targetSquare + " Capture: " + isCapture + " Pawn: " + isPawnMove + " Ranged: " + isRangedAttack + " P1T: "+player1TimeRemaining+" P2T: "+player2TimeRemaining); db.runTransaction((Transaction.Function<Void>) transaction -> { DocumentSnapshot gameSnapshot = transaction.get(gameRef); if (!gameSnapshot.exists()) throw new FirebaseFirestoreException("Game not found.", FirebaseFirestoreException.Code.NOT_FOUND); GameModel game = gameSnapshot.toObject(GameModel.class); if (game == null) throw new FirebaseFirestoreException("Failed to parse game data.", FirebaseFirestoreException.Code.DATA_LOSS); String movingPlayerId = game.getCurrentTurnPlayerId(); String movingPlayerColor = game.getPlayerColorById(movingPlayerId); String pieceColor = getPieceColorFromValue(pieceValue); if (game.getStatusEnum() != GameStatus.ACTIVE) { throw new FirebaseFirestoreException("Game is not active.", FirebaseFirestoreException.Code.FAILED_PRECONDITION); } if (movingPlayerColor == null || pieceColor == null || !movingPlayerColor.equalsIgnoreCase(pieceColor)) { Log.w(TAG, "Move validation failed: Attempted move " + pieceValue + " but current turn is " + movingPlayerColor + " (Player ID: " + movingPlayerId + ")"); throw new FirebaseFirestoreException("Not your turn or invalid piece color.", FirebaseFirestoreException.Code.FAILED_PRECONDITION); } Map<String, Object> currentBoardState = game.getBoardState(); if (currentBoardState == null) { throw new FirebaseFirestoreException("Board state is missing.", FirebaseFirestoreException.Code.DATA_LOSS); } Map<String, Object> newBoardState = new HashMap<>(currentBoardState); Object valueOnBoardObj = newBoardState.get(originalSquare); if (!(valueOnBoardObj instanceof String)) { Log.w(TAG, "Validation failed: No piece found at " + originalSquare); throw new FirebaseFirestoreException("Piece not found at original square (empty or invalid type).", FirebaseFirestoreException.Code.FAILED_PRECONDITION); } String valueOnBoard = (String) valueOnBoardObj; String baseValueOnBoard = valueOnBoard.endsWith(MOVED_SUFFIX) ? valueOnBoard.substring(0, valueOnBoard.length() - MOVED_SUFFIX.length()) : valueOnBoard; if (!Objects.equals(pieceValue, baseValueOnBoard)) { Log.w(TAG, "Standard move validation failed: Piece " + pieceValue + " not found at " + originalSquare + ". Found: " + valueOnBoard); throw new FirebaseFirestoreException("Piece not found at original square.", FirebaseFirestoreException.Code.FAILED_PRECONDITION); } if (isRangedAttack) { Log.d(TAG, "TX: Processing RANGED attack."); if (!newBoardState.containsKey(targetSquare)) { Log.w(TAG, "Ranged attack validation failed: Target square " + targetSquare + " is empty."); throw new FirebaseFirestoreException("Ranged attack target square is empty.", FirebaseFirestoreException.Code.FAILED_PRECONDITION); } newBoardState.remove(targetSquare); Log.d(TAG, "TX: Ranged attack removed piece at " + targetSquare + ". Attacker at " + originalSquare + " remains."); } else { Log.d(TAG, "TX: Processing STANDARD move."); newBoardState.remove(originalSquare); String finalPieceValueOnTarget = pieceValue; String pieceType = getPieceTypeFromValue(pieceValue); if (pieceType != null && (pieceType.equals("PAWN") || pieceType.equals("ROOK") || pieceType.equals("KING"))) { finalPieceValueOnTarget += MOVED_SUFFIX; Log.d(TAG, "TX: Appending " + MOVED_SUFFIX + " to " + pieceValue + " for target square " + targetSquare); } newBoardState.put(targetSquare, finalPieceValueOnTarget); Log.d(TAG, "TX: Standard move removed piece from " + originalSquare + ", placed " + finalPieceValueOnTarget + " at " + targetSquare); } int currentFiftyMoveCounter = game.getFiftyMoveRuleCounter(); List<String> currentPositionHistory = game.getPositionHistory(); int nextFiftyMoveCounter; List<String> nextPositionHistory = new ArrayList<>(currentPositionHistory != null ? currentPositionHistory : new ArrayList<>()); BoardPosition nextEnPassantTarget = null; if (!isRangedAttack && isPawnMove) { BoardPosition startPos = GameModel.algebraicToBoardPosition(originalSquare); BoardPosition endPos = GameModel.algebraicToBoardPosition(targetSquare); if (startPos != null && endPos != null && Math.abs(endPos.getY() - startPos.getY()) == 2) { int direction = (Team.WHITE.name().equalsIgnoreCase(pieceColor)) ? 1 : -1; nextEnPassantTarget = startPos.add(0, direction); Log.d(TAG, "Pawn moved two squares, setting EP target for next turn: " + GameModel.boardPositionToAlgebraic(nextEnPassantTarget)); } } if (isCapture || isPawnMove || isRangedAttack) { nextFiftyMoveCounter = 0; nextPositionHistory.clear(); Log.d(TAG, "Resetting draw counters/history due to capture/pawn move/ranged attack."); } else { nextFiftyMoveCounter = currentFiftyMoveCounter + 1; String nextPlayerColor = game.getPlayerColorById(nextTurnPlayerId); Map<String, String> newBoardStateStrMap = convertObjectMapToStringMap(newBoardState); String epTargetString = (nextEnPassantTarget != null) ? GameModel.boardPositionToAlgebraic(nextEnPassantTarget) : "-"; String newStateString = GameModel.generateBoardStateString(newBoardStateStrMap, nextPlayerColor != null ? nextPlayerColor : "?", "-", epTargetString); if (newStateString != null) { nextPositionHistory.add(newStateString); while (nextPositionHistory.size() > POSITION_HISTORY_LIMIT) { nextPositionHistory.remove(0); } } } Map<String, Object> updates = new HashMap<>(); updates.put("boardState", newBoardState); updates.put("currentTurnPlayerId", nextTurnPlayerId); updates.put("fiftyMoveRuleCounter", nextFiftyMoveCounter); updates.put("positionHistory", nextPositionHistory); updates.put("enPassantTargetSquareString", nextEnPassantTarget != null ? GameModel.boardPositionToAlgebraic(nextEnPassantTarget) : null); FieldValue serverTimestamp = FieldValue.serverTimestamp(); updates.put("lastUpdateTime", serverTimestamp); String lastSeenField = movingPlayerId.equals(game.getPlayer1Id()) ? "player1LastSeen" : "player2LastSeen"; updates.put(lastSeenField, serverTimestamp); updates.put("player1TimeRemainingMillis", player1TimeRemaining); updates.put("player2TimeRemainingMillis", player2TimeRemaining); updates.put("drawOfferedByPlayerId", null); Log.d(TAG, "TX_performMove: updates=" + updates.keySet()); transaction.update(gameRef, updates); return null; }).addOnSuccessListener(aVoid -> { Log.i(TAG, "performMove transaction successful for game: " + gameId); if (listener != null) mainThreadExecutor.execute(listener::onSuccess); }).addOnFailureListener(e -> { Log.e(TAG, "performMove transaction failed for game: " + gameId, e); if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Move failed: " + e.getMessage())); }); }
    @Override public void performSpellCast(String gameId, String castingPlayerId, String spellName, @Nullable Map<String, String> targetInfo, long player1TimeRemaining, long player2TimeRemaining, AuthListener listener) { if (gameId == null || castingPlayerId == null || spellName == null) { if(listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Invalid spell arguments")); Log.e(TAG, "performSpellCast called with null arguments"); return; } DocumentReference gameRef = db.collection(GAMES_COLLECTION).document(gameId); Log.i(TAG, "Spell cast network sync: Player " + castingPlayerId + " casting " + spellName + " targets: " + targetInfo + " P1T: "+player1TimeRemaining+" P2T: "+player2TimeRemaining); db.runTransaction((Transaction.Function<Void>) transaction -> { DocumentSnapshot gameSnapshot = transaction.get(gameRef); if (!gameSnapshot.exists()) throw new FirebaseFirestoreException("Game not found.", FirebaseFirestoreException.Code.NOT_FOUND); GameModel game = gameSnapshot.toObject(GameModel.class); if (game == null) throw new FirebaseFirestoreException("Failed to parse game data.", FirebaseFirestoreException.Code.DATA_LOSS); if (game.getStatusEnum() != GameStatus.ACTIVE) { throw new FirebaseFirestoreException("Game is not active.", FirebaseFirestoreException.Code.FAILED_PRECONDITION); } if (!castingPlayerId.equals(game.getCurrentTurnPlayerId())) { throw new FirebaseFirestoreException("Not your turn.", FirebaseFirestoreException.Code.FAILED_PRECONDITION); } String playerSpellsField = castingPlayerId.equals(game.getPlayer1Id()) ? "player1Spells" : "player2Spells"; Object spellsObj = gameSnapshot.get(playerSpellsField); List<String> playerSpells; if (spellsObj instanceof List) { try { @SuppressWarnings("unchecked") List<String> castedList = (List<String>) spellsObj; playerSpells = new ArrayList<>(castedList); } catch (ClassCastException cce) { Log.e(TAG, "Internal error reading spell list for " + playerSpellsField, cce); throw new FirebaseFirestoreException("Internal error: Cannot read spell list.", FirebaseFirestoreException.Code.INTERNAL); } } else { Log.w(TAG, "Player spell list field '"+playerSpellsField+"' missing or not a List. Assuming empty."); playerSpells = new ArrayList<>(); } final String upperSpellName = spellName.toUpperCase(); boolean removed = playerSpells.removeIf(s -> s.equalsIgnoreCase(upperSpellName)); if (!removed) { Log.w(TAG, "Player " + castingPlayerId + " attempted to cast unavailable spell: " + spellName + " (Available: " + playerSpells + ")"); throw new FirebaseFirestoreException("Player does not have spell: " + spellName, FirebaseFirestoreException.Code.FAILED_PRECONDITION); } SpellConfig spellConfig = SpellFactory.getConfig(spellName); if (spellConfig == null) { throw new FirebaseFirestoreException("Unknown spell type: " + spellName, FirebaseFirestoreException.Code.INVALID_ARGUMENT); } String opponentId = game.getOpponentId(castingPlayerId); if (opponentId == null) throw new FirebaseFirestoreException("Cannot find opponent ID.", FirebaseFirestoreException.Code.INTERNAL); String nextTurnId = spellConfig.endsTurn ? opponentId : castingPlayerId; Map<String, Object> updates = new HashMap<>(); updates.put(playerSpellsField, playerSpells); updates.put("currentTurnPlayerId", nextTurnId); FieldValue serverTimestamp = FieldValue.serverTimestamp(); updates.put("lastUpdateTime", serverTimestamp); String lastSeenField = castingPlayerId.equals(game.getPlayer1Id()) ? "player1LastSeen" : "player2LastSeen"; updates.put(lastSeenField, serverTimestamp); updates.put("player1TimeRemainingMillis", player1TimeRemaining); updates.put("player2TimeRemainingMillis", player2TimeRemaining); updates.put("drawOfferedByPlayerId", null); Map<String, Object> currentBoard = game.getBoardState(); Map<String, Object> newBoard = new HashMap<>(currentBoard != null ? currentBoard : new HashMap<>()); boolean boardChanged = false; if (spellConfig.effectComponents != null) { for (SpellConfig.SpellEffectComponentConfig componentConfig : spellConfig.effectComponents) { if ("DESTROY_TARGET".equals(componentConfig.type)) { if (targetInfo != null && targetInfo.containsKey("targetSquare")) { String targetSquare = targetInfo.get("targetSquare"); if (newBoard.containsKey(targetSquare)) { newBoard.remove(targetSquare); boardChanged = true; Log.d(TAG, "TX: Spell effect DESTROY_TARGET removed piece at " + targetSquare); updates.put("fiftyMoveRuleCounter", 0); updates.put("positionHistory", new ArrayList<String>()); } else { Log.w(TAG, "TX: Spell effect DESTROY_TARGET target square " + targetSquare + " already empty or invalid."); } } else if (componentConfig.params != null && Boolean.parseBoolean(componentConfig.params.getOrDefault("allow_empty", "false"))) { Log.d(TAG, "TX: Spell effect DESTROY_TARGET allowed empty target, no board change."); } else { Log.e(TAG, "TX: Spell effect DESTROY_TARGET requires a valid target square, but none provided or found. Check spell config and client logic."); } } } } if (boardChanged) { updates.put("boardState", newBoard); } Log.d(TAG, "TX_performSpellCast: updates=" + updates.keySet()); transaction.update(gameRef, updates); return null; }).addOnSuccessListener(aVoid -> { Log.i(TAG, "performSpellCast transaction successful for game: " + gameId); if (listener != null) mainThreadExecutor.execute(listener::onSuccess); }).addOnFailureListener(e -> { Log.e(TAG, "performSpellCast transaction failed for game: " + gameId, e); if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Spell cast failed: " + e.getMessage())); }); }
    @Override public void recordGameResult(String gameId, @Nullable String winnerId, @Nullable String loserId, String winReason, AuthListener listener) { if (gameId == null || winReason == null) { if(listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Invalid arguments for recordGameResult")); Log.e(TAG, "recordGameResult called with null gameId or winReason"); return; } boolean isDraw = (winnerId == null && loserId == null) || WIN_REASON_STALEMATE.equals(winReason) || WIN_REASON_DRAW_AGREEMENT.equals(winReason) || DRAW_REASON_REPETITION.equals(winReason) || DRAW_REASON_50_MOVE.equals(winReason) || DRAW_REASON_MATERIAL.equals(winReason); if (!isDraw && (winnerId == null || loserId == null || Objects.equals(winnerId, loserId))) { if(listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Invalid winner/loser IDs for non-draw result.")); Log.e(TAG, "recordGameResult invalid winner/loser IDs. W:" + winnerId + ", L:" + loserId + ", Draw:" + isDraw + ", Reason: " + winReason); return; } DocumentReference gameRef = db.collection(GAMES_COLLECTION).document(gameId); Log.i(TAG, "Recording result '" + winReason + "' for game " + gameId + ". W: " + winnerId + ", L: " + loserId + ", Draw: " + isDraw); db.runTransaction((Transaction.Function<Void>) transaction -> { DocumentSnapshot gameSnapshot = transaction.get(gameRef); if (!gameSnapshot.exists()) throw new FirebaseFirestoreException("Game not found.", FirebaseFirestoreException.Code.NOT_FOUND); GameModel game = gameSnapshot.toObject(GameModel.class); if (game == null) throw new FirebaseFirestoreException("Game parse fail.", FirebaseFirestoreException.Code.DATA_LOSS); if (game.getStatusEnum() == GameStatus.FINISHED) { Log.w(TAG, "Attempted to record result for already finished game: " + gameId); throw new FirebaseFirestoreException("Game is already finished.", FirebaseFirestoreException.Code.ABORTED); } String p1Id = game.getPlayer1Id(); String p2Id = game.getPlayer2Id(); if (p1Id == null || p2Id == null) throw new FirebaseFirestoreException("Game missing player IDs.", FirebaseFirestoreException.Code.DATA_LOSS); if (!isDraw) { if (!((winnerId.equals(p1Id) && loserId.equals(p2Id)) || (winnerId.equals(p2Id) && loserId.equals(p1Id)))) { throw new FirebaseFirestoreException("Winner/Loser IDs do not match game players.", FirebaseFirestoreException.Code.INVALID_ARGUMENT); } } DocumentReference p1Ref = db.collection(USERS_COLLECTION).document(p1Id); DocumentReference p2Ref = db.collection(USERS_COLLECTION).document(p2Id); DocumentSnapshot p1Snap = transaction.get(p1Ref); DocumentSnapshot p2Snap = transaction.get(p2Ref); if (!p1Snap.exists() || !p2Snap.exists()) throw new FirebaseFirestoreException("Player profile missing.", FirebaseFirestoreException.Code.NOT_FOUND); UserModel p1 = p1Snap.toObject(UserModel.class); UserModel p2 = p2Snap.toObject(UserModel.class); if (p1 == null || p2 == null) throw new FirebaseFirestoreException("Profile parse fail.", FirebaseFirestoreException.Code.DATA_LOSS); p1.setUserId(p1Id); p2.setUserId(p2Id); int eloChangeP1 = 0; int eloChangeP2 = 0; int newEloP1 = p1.getEloRating(); int newEloP2 = p2.getEloRating(); if (!isDraw) { UserModel winner = winnerId.equals(p1Id) ? p1 : p2; UserModel loser = loserId.equals(p1Id) ? p1 : p2; double wEx = 1.0 / (1.0 + Math.pow(10.0, (loser.getEloRating() - winner.getEloRating()) / 400.0)); double lEx = 1.0 - wEx; int eloW_ch = (int) Math.round(K_FACTOR * (1.0 - wEx)); int eloL_ch = (int) Math.round(K_FACTOR * (0.0 - lEx)); int newW_elo = Math.max(100, winner.getEloRating() + eloW_ch); int newL_elo = Math.max(100, loser.getEloRating() + eloL_ch); eloW_ch = newW_elo - winner.getEloRating(); eloL_ch = newL_elo - loser.getEloRating(); if (winnerId.equals(p1Id)) { eloChangeP1 = eloW_ch; newEloP1 = newW_elo; eloChangeP2 = eloL_ch; newEloP2 = newL_elo; } else { eloChangeP1 = eloL_ch; newEloP1 = newL_elo; eloChangeP2 = eloW_ch; newEloP2 = newW_elo; } } Map<String, Object> gameUpdates = new HashMap<>(); gameUpdates.put("status", GameStatus.FINISHED.getFirestoreValue()); gameUpdates.put("winnerId", isDraw ? null : winnerId); gameUpdates.put("loserId", isDraw ? null : loserId); gameUpdates.put("winReason", winReason); gameUpdates.put("drawOfferedByPlayerId", null); gameUpdates.put("eloChangePlayer1", eloChangeP1); gameUpdates.put("eloChangePlayer2", eloChangeP2); gameUpdates.put("lastUpdateTime", FieldValue.serverTimestamp()); Log.d(TAG, "TX_recordResult: gameUpdates=" + gameUpdates); transaction.update(gameRef, gameUpdates); Map<String, Object> p1Updates = new HashMap<>(); p1Updates.put("eloRating", newEloP1); p1Updates.put("gamesPlayed", FieldValue.increment(1)); if (!isDraw && p1Id.equals(winnerId)) { p1Updates.put("gamesWon", FieldValue.increment(1)); } Log.d(TAG, "TX_recordResult: p1Updates=" + p1Updates); transaction.update(p1Ref, p1Updates); Map<String, Object> p2Updates = new HashMap<>(); p2Updates.put("eloRating", newEloP2); p2Updates.put("gamesPlayed", FieldValue.increment(1)); if (!isDraw && p2Id.equals(winnerId)) { p2Updates.put("gamesWon", FieldValue.increment(1)); } Log.d(TAG, "TX_recordResult: p2Updates=" + p2Updates); transaction.update(p2Ref, p2Updates); return null; }).addOnSuccessListener(aVoid -> { Log.i(TAG, "recordGameResult transaction successful for game: " + gameId); if (listener != null) mainThreadExecutor.execute(listener::onSuccess); }).addOnFailureListener(e -> { Log.e(TAG, "recordGameResult transaction failed for game: " + gameId, e); if (listener != null) { String msg = e.getMessage(); if (e instanceof FirebaseFirestoreException && ((FirebaseFirestoreException)e).getCode()==FirebaseFirestoreException.Code.ABORTED) { msg="Game already finished or precondition failed."; } final String finalMsg = msg; mainThreadExecutor.execute(() -> listener.onFailure("Result recording failed: " + finalMsg)); } }); }


    @Override
    public void fetchMatchHistory(String userId, MatchHistoryListener listener) {
        if (userId == null || listener == null) {
            if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("User ID or listener is null."));
            return;
        }
        Log.d(TAG, "Fetching match history for user: " + userId);

        db.collection(GAMES_COLLECTION)
                .whereArrayContains("playerIds", userId)
                .whereEqualTo("status", GameStatus.FINISHED.getFirestoreValue())
                .orderBy("lastUpdateTime", Query.Direction.DESCENDING)
                .limit(MATCH_HISTORY_LIMIT)
                .get()
                .addOnCompleteListener(task -> {
                    if (task.isSuccessful()) {
                        List<MatchHistoryEntry> history = new ArrayList<>();
                        QuerySnapshot snapshot = task.getResult();
                        if (snapshot != null && !snapshot.isEmpty()) {
                            Log.d(TAG, "Found " + snapshot.size() + " finished games for user " + userId);
                            for (QueryDocumentSnapshot doc : snapshot) {
                                try {
                                    String player1Id = doc.getString("player1Id");
                                    String player2Id = doc.getString("player2Id");
                                    String player1Name = doc.getString("player1DisplayName");
                                    String player2Name = doc.getString("player2DisplayName");
                                    String winnerId = doc.getString("winnerId");
                                    String loserId = doc.getString("loserId");
                                    Long eloChange1Long = doc.getLong("eloChangePlayer1");
                                    Long eloChange2Long = doc.getLong("eloChangePlayer2");
                                    Timestamp timestamp = doc.getTimestamp("lastUpdateTime");

                                    if (player1Id == null || player2Id == null || timestamp == null) {
                                        Log.w(TAG, "Skipping game " + doc.getId() + ": Missing player IDs or timestamp.");
                                        continue;
                                    }

                                    String opponentName;
                                    int eloChange;
                                    if (userId.equals(player1Id)) {
                                        opponentName = player2Name != null ? player2Name : "Opponent";
                                        eloChange = (eloChange1Long != null) ? eloChange1Long.intValue() : 0;
                                    } else if (userId.equals(player2Id)) {
                                        opponentName = player1Name != null ? player1Name : "Opponent";
                                        eloChange = (eloChange2Long != null) ? eloChange2Long.intValue() : 0;
                                    } else {
                                        Log.w(TAG, "Skipping game " + doc.getId() + ": User " + userId + " not found in player IDs.");
                                        continue;
                                    }

                                    String result;
                                    if (winnerId == null && loserId == null) { result = "Draw"; }
                                    else if (userId.equals(winnerId)) { result = "Win"; }
                                    else if (userId.equals(loserId)) { result = "Loss"; }
                                    else { result = "Unknown"; }

                                    String eloChangeString = (eloChange > 0) ? "+" + eloChange : String.valueOf(eloChange);

                                    history.add(new MatchHistoryEntry(opponentName, result, eloChangeString, timestamp.toDate().getTime()));

                                } catch (Exception e) {
                                    Log.e(TAG, "Error parsing match history entry from game " + doc.getId(), e);
                                }
                            }
                            // Ensure sorting by timestamp descending (although query should handle it)
                            history.sort(Comparator.comparingLong(MatchHistoryEntry::getTimestamp).reversed());

                        } else {
                            Log.d(TAG, "No finished games found for user: " + userId);
                        }
                        if (listener != null) mainThreadExecutor.execute(() -> listener.onSuccess(history));

                    } else {
                        String errorMsg = task.getException() != null ? task.getException().getMessage() : "Unknown Firestore error.";
                        Log.e(TAG, "Error fetching match history for user " + userId + ": " + errorMsg, task.getException());
                        if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Error fetching history: " + errorMsg));
                    }
                });
    }


    // --- Private Helpers ---
    private Map<String, String> generatePlayerInitialPieces(String playerColor, DeckModel deckModel) { Map<String, String> pieces = new HashMap<>(); if (deckModel == null || playerColor == null) return pieces; String[] files = {"a", "b", "c", "d", "e", "f", "g", "h"}; boolean isWhite = "white".equalsIgnoreCase(playerColor); String prefix = isWhite ? "WHITE_" : "BLACK_"; String backRank = isWhite ? "1" : "8"; String frontRank = isWhite ? "2" : "7"; for (int i = 0; i < DeckModel.PIECE_GRID_SIZE; i++) { String typeName = deckModel.getPieceTypeNameAt(i); if (typeName != null && !typeName.isEmpty()) { int fileIdx = i % 8; String file = files[fileIdx]; String rank = (i < 8) ? backRank : frontRank; String square = file + rank; pieces.put(square, prefix + typeName.toUpperCase()); } } Log.d(TAG, "Generated initial pieces for " + playerColor + ": " + pieces); return pieces; }
    private String getPieceColorFromValue(String pieceValue) { if (pieceValue == null || !pieceValue.contains("_")) return null; String baseValue = pieceValue.replace(MOVED_SUFFIX, ""); return baseValue.substring(0, baseValue.indexOf('_')).toUpperCase(); }
    private String getPieceTypeFromValue(String pieceValue) { if (pieceValue == null || !pieceValue.contains("_")) return null; String baseValue = pieceValue.replace(MOVED_SUFFIX, ""); return baseValue.substring(baseValue.indexOf('_') + 1).toUpperCase(); }
    private Map<String, String> convertObjectMapToStringMap(Map<String, Object> objMap) { if (objMap == null) return new HashMap<>(); Map<String, String> strMap = new HashMap<>(); for (Map.Entry<String, Object> entry : objMap.entrySet()) { if (entry.getValue() instanceof String) { strMap.put(entry.getKey(), (String) entry.getValue()); } else if (entry.getValue() != null) { Log.w(TAG, "convertObjectMapToStringMap: Unexpected type " + entry.getValue().getClass().getName() + " for key " + entry.getKey()); } } return strMap; }
    private long calculateInitialTimeMillis(String timeLimit) { if (timeLimit == null || timeLimit.equalsIgnoreCase("Unlimited")) { return Long.MAX_VALUE / 4; } try { String[] parts = timeLimit.split(" "); if (parts.length == 2 && parts[1].toLowerCase().startsWith("min")) { long minutes = Long.parseLong(parts[0]); if (minutes <= 0) { Log.w(TAG, "Invalid time limit minutes: " + minutes + ". Using default 5 min."); return 5 * 60 * 1000L; } return minutes * 60 * 1000L; } } catch (Exception e) { Log.e(TAG, "Failed to parse time limit string: '" + timeLimit + "'. Defaulting to 5 min.", e); } Log.w(TAG, "Using default time limit (5 min) due to parsing issue with: " + timeLimit); return 5 * 60 * 1000L; }
    private void enterMatchmaking(String userId, String displayName, int elo, int pointLimit, String timeLimit, String deckName, AuthListener queueListener) { if (userId == null || displayName == null || timeLimit == null || deckName == null) { if (queueListener != null) mainThreadExecutor.execute(() -> queueListener.onFailure("Missing matchmaking details.")); return; } db.collection(GAMES_COLLECTION) .whereArrayContains("playerIds", userId) .whereIn("status", Arrays.asList(GameStatus.ACTIVE.getFirestoreValue(), GameStatus.PENDING_JOIN.getFirestoreValue(), GAME_STATUS_PENDING_CODE_JOIN)) .limit(1) .get() .addOnCompleteListener(checkTask -> { if (!checkTask.isSuccessful()) { Log.e(TAG, "Error checking existing games for user " + userId, checkTask.getException()); if (queueListener != null) mainThreadExecutor.execute(() -> queueListener.onFailure("Error checking active games: " + (checkTask.getException() != null ? checkTask.getException().getMessage() : "Unknown"))); return; } if (checkTask.getResult() != null && !checkTask.getResult().isEmpty()) { Log.w(TAG, "User " + userId + " tried to enter ranked matchmaking but is already in game: " + checkTask.getResult().getDocuments().get(0).getId()); if (queueListener != null) mainThreadExecutor.execute(() -> queueListener.onFailure("Already in an active game.")); return; } Log.d(TAG, "User " + userId + " not in active game. Checking ranked matchmaking queue..."); Query query = db.collection(MATCHMAKING_COLLECTION) .whereEqualTo("pointLimit", pointLimit) .whereEqualTo("timeLimit", timeLimit) .orderBy("timestamp"); query.get().addOnCompleteListener(task -> { if (task.isSuccessful() && task.getResult() != null) { DocumentSnapshot opponentDoc = null; for (DocumentSnapshot doc : task.getResult()) { String potentialOpponentId = doc.getId(); if (potentialOpponentId.equals(userId)) continue; Long oppEloLong = doc.getLong("elo"); if (oppEloLong == null) continue; int oppElo = oppEloLong.intValue(); if (Math.abs(oppElo - elo) <= MAX_ELO_DIFF) { opponentDoc = doc; break; } } if (opponentDoc != null) { String opponentId = opponentDoc.getId(); String opponentName = opponentDoc.getString("displayName"); String opponentDeckName = opponentDoc.getString("deckName"); Long opponentEloLong = opponentDoc.getLong("elo"); int opponentElo = (opponentEloLong != null) ? opponentEloLong.intValue() : 1000; Log.i(TAG, "Ranked Match found! " + userId + " (" + elo + ") vs " + opponentId + " (" + opponentElo + ")"); createGameAtomically(userId, displayName, deckName, elo, opponentId, opponentName, opponentDeckName, opponentElo, pointLimit, timeLimit, queueListener); } else { Log.i(TAG, "No suitable ranked opponent found for " + userId + ". Adding to queue."); addPlayerToQueue(userId, displayName, elo, pointLimit, timeLimit, deckName, queueListener); } } else { Log.e(TAG, "Ranked matchmaking query failed for user " + userId, task.getException()); if (queueListener != null) mainThreadExecutor.execute(() -> queueListener.onFailure("Matchmaking query failed: " + (task.getException() != null ? task.getException().getMessage() : "Unknown"))); } }); }); }
    private Object listenForMyGame(String userId, GameFoundListener listener) { if (userId == null || listener == null) return null; if (activeRankedGameSearchListener != null) { Log.w(TAG, "Stopping previous ranked game search listener before starting new one for user: " + userId); stopListeningForMyGame(activeRankedGameSearchListener); } this.listeningForRankedUserId = userId; Query gameQuery = db.collection(GAMES_COLLECTION) .whereArrayContains("playerIds", userId) .whereIn("status", Arrays.asList(GameStatus.ACTIVE.getFirestoreValue(), GameStatus.PENDING_JOIN.getFirestoreValue())) .orderBy("lastUpdateTime", Query.Direction.DESCENDING) .limit(1); Log.d(TAG, "Starting listener for RANKED games involving userId: " + userId); activeRankedGameSearchListener = gameQuery.addSnapshotListener(mainThreadExecutor, (querySnapshot, error) -> { if (error != null) { Log.e(TAG, "listenForMyRankedGame error for user " + userId, error); listener.onError(error.getMessage()); return; } if (querySnapshot != null && !querySnapshot.isEmpty()) { DocumentSnapshot gameDoc = querySnapshot.getDocuments().get(0); try { GameModel gm = gameDoc.toObject(GameModel.class); if (gm != null) { gm.setGameId(gameDoc.getId()); if (gm.getPlayer1Spells() == null) gm.setPlayer1Spells(new ArrayList<>()); if (gm.getPlayer2Spells() == null) gm.setPlayer2Spells(new ArrayList<>()); GameStatus currentStatus = gm.getStatusEnum(); Log.d(TAG, "Ranked Game found/updated via listener: ID=" + gm.getGameId() + ", Status=" + currentStatus + ", User=" + userId); if (currentStatus == GameStatus.ACTIVE && gm.getPlayer1Id() != null && gm.getPlayer2Id() != null) { Log.i(TAG, "Active ranked game found! Triggering onGameFound for game " + gm.getGameId()); Object listenerToRemove = activeRankedGameSearchListener; activeRankedGameSearchListener = null; listeningForRankedUserId = null; stopListeningForMyGame(listenerToRemove); listener.onGameFound(gm); } else if (currentStatus == GameStatus.PENDING_JOIN) { Log.d(TAG, "Ranked Game found but still PENDING_JOIN (ID: " + gm.getGameId() + "), listener remains active."); } else { Log.w(TAG, "Ranked Game found (ID: " + gm.getGameId() + ") but status is '" + currentStatus + "' or player missing, stopping listener."); Object listenerToRemove = activeRankedGameSearchListener; activeRankedGameSearchListener = null; listeningForRankedUserId = null; stopListeningForMyGame(listenerToRemove); } } else { Log.e(TAG, "Failed to parse ranked game data for document: " + gameDoc.getId()); listener.onError("Failed to parse game data."); } } catch (Exception e) { Log.e(TAG, "Exception parsing ranked game data for document: " + gameDoc.getId(), e); listener.onError("Error parsing game: " + e.getMessage()); } } else { Log.d(TAG, "listenForMyRankedGame: Query snapshot empty for user " + userId); } }); return activeRankedGameSearchListener; }
    private void stopListeningForMyGame(Object listenerRegistration) { if (listenerRegistration instanceof ListenerRegistration) { if (listenerRegistration == activeRankedGameSearchListener) { ((ListenerRegistration) activeRankedGameSearchListener).remove(); activeRankedGameSearchListener = null; listeningForRankedUserId = null; Log.i(TAG,"Stopped and cleared active ranked game search listener."); } else { ((ListenerRegistration) listenerRegistration).remove(); Log.d(TAG,"Stopped provided (potentially old) ranked game search listener instance."); } } else if (listenerRegistration != null) { Log.w(TAG, "stopListeningForMyGame called with invalid object type: " + listenerRegistration.getClass().getName()); } }
    private void addPlayerToQueue(String userId, String displayName, int elo, int pointLimit, String timeLimit, String deckName, AuthListener listener) { Map<String, Object> entry = new HashMap<>(); entry.put("userId", userId); entry.put("displayName", displayName); entry.put("elo", elo); entry.put("pointLimit", pointLimit); entry.put("timeLimit", timeLimit); entry.put("deckName", deckName); entry.put("timestamp", FieldValue.serverTimestamp()); db.collection(MATCHMAKING_COLLECTION).document(userId) .set(entry, SetOptions.merge()) .addOnSuccessListener(aVoid -> { Log.i(TAG, "Player " + userId + " added/updated in RANKED queue."); if (listener != null) mainThreadExecutor.execute(listener::onSuccess); }) .addOnFailureListener(e -> { Log.e(TAG, "Failed add player " + userId + " to RANKED queue.", e); if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("Failed to enter queue: " + e.getMessage())); }); }
    private void cancelMatchmaking(String userId, AuthListener listener) { if (userId == null) { if (listener != null) mainThreadExecutor.execute(() -> listener.onFailure("User ID missing.")); return; } if (userId.equals(listeningForRankedUserId) && activeRankedGameSearchListener != null) { Log.d(TAG, "Cancelling ranked matchmaking includes stopping active listener for user: " + userId); stopListeningForMyGame(activeRankedGameSearchListener); } db.collection(MATCHMAKING_COLLECTION).document(userId).delete() .addOnSuccessListener(aVoid -> { Log.i(TAG,"Removed " + userId + " from ranked matchmaking queue (or wasn't there)."); if (listener != null) mainThreadExecutor.execute(listener::onSuccess); }) .addOnFailureListener(e -> { Log.w(TAG,"Failed remove " + userId + " from ranked queue (might not have been there): " + e.getMessage()); if (listener != null) mainThreadExecutor.execute(listener::onSuccess); }); }
    private void createGameAtomically(String p1Id, String p1Name, String p1DeckName, int p1Elo, String p2Id, String p2Name, String p2DeckName, int p2Elo, int pLimit, String tLimit, @Nullable AuthListener cb) { DocumentReference gameRef = db.collection(GAMES_COLLECTION).document(); DocumentReference p2QueueRef = db.collection(MATCHMAKING_COLLECTION).document(p2Id); db.runTransaction((Transaction.Function<Void>) transaction -> { DocumentSnapshot opponentQueueSnapshot = transaction.get(p2QueueRef); if (!opponentQueueSnapshot.exists()) { Log.w(TAG, "Opponent " + p2Id + " not found in ranked queue. Aborting game creation."); throw new FirebaseFirestoreException("Opponent left queue.", FirebaseFirestoreException.Code.ABORTED); } Map<String, Object> gameData = new HashMap<>(); gameData.put("player1Id", p1Id); gameData.put("player2Id", p2Id); gameData.put("playerIds", Arrays.asList(p1Id, p2Id)); gameData.put("player1DisplayName", p1Name); gameData.put("player2DisplayName", p2Name); gameData.put("player1DeckName", p1DeckName); gameData.put("player2DeckName", p2DeckName); gameData.put("pointLimit", pLimit); gameData.put("timeLimit", tLimit); String p1Color = new Random().nextBoolean() ? "white" : "black"; String p2Color = p1Color.equals("white") ? "black" : "white"; gameData.put("player1Color", p1Color); gameData.put("player2Color", p2Color); gameData.put("status", GameStatus.ACTIVE.getFirestoreValue()); gameData.put("currentTurnPlayerId", p1Color.equals("white") ? p1Id : p2Id); gameData.put("boardState", new HashMap<>()); long initialTime = calculateInitialTimeMillis(tLimit); gameData.put("player1TimeRemainingMillis", initialTime); gameData.put("player2TimeRemainingMillis", initialTime); FieldValue serverTimestamp = FieldValue.serverTimestamp(); gameData.put("lastUpdateTime", serverTimestamp); gameData.put("player1LastSeen", serverTimestamp); gameData.put("player2LastSeen", serverTimestamp); gameData.put("drawOfferedByPlayerId", null); gameData.put("winnerId", null); gameData.put("loserId", null); gameData.put("winReason", null); gameData.put("eloChangePlayer1", 0); gameData.put("eloChangePlayer2", 0); gameData.put("fiftyMoveRuleCounter", 0); gameData.put("positionHistory", new ArrayList<String>()); gameData.put("enPassantTargetSquareString", null); gameData.put("player1Spells", new ArrayList<String>()); gameData.put("player2Spells", new ArrayList<String>()); transaction.set(gameRef, gameData); transaction.delete(p2QueueRef); Log.d(TAG, "Transaction: Creating RANKED game " + gameRef.getId() + ", deleting " + p2Id + " from queue."); return null; }) .addOnSuccessListener(aVoid -> { Log.i(TAG, "Ranked game creation transaction successful! Game ID: " + gameRef.getId()); if (cb != null) mainThreadExecutor.execute(cb::onSuccess); }) .addOnFailureListener(e -> { Log.e(TAG, "Ranked game creation transaction failed.", e); if (cb != null) mainThreadExecutor.execute(() -> cb.onFailure("Failed to create match: " + e.getMessage())); }); }

}